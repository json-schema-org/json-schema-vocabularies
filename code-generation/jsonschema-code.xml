<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3339 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC6901 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6901.xml">
<!ENTITY RFC7159 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes" ?>
<rfc category="info" docName="draft-kappestein-json-schema-code-00" ipr="trust200902">
    <front>
        <title abbrev="JSON Schema Code">JSON Schema Code: JSON Schema rules to simplify code generation</title>
        <author fullname="Christoph Kappestein" initials="C" surname="Kappestein" role="editor">
            <address>
                <email>christoph.kappestein@gmail.com</email>
            </address>
        </author>
        <date year="2017"/>
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>Code Generation</keyword>
        <abstract>
            <t>
                JSON Schema provides many ways to describe a JSON structure. The 
                price of this flexibility is that it is difficult for code generators 
                to understand a JSON Schema. This specification restricts the JSON Schema 
                keywords to a subset with a deterministic behaviour.
            </t>
        </abstract>
    </front>
    <middle>
        <section title="Introduction">
            <t>
                This vocabulary restricts the JSON Schema Validation keywords to 
                a clear subset which removes ambiguities and inherent invalid schemas.
            </t>
            <t>
                If a JSON Schema follows these rules it is easier for processor and
                code generators to consume. This leads to better results and
                maintainability of a schema.
            </t>
            <t>
                It includes also some new keywords from the OpenAPI v3 specification
                which are dedicated to code generation.
            </t>
            <t>
                This specification should be seen as extension to the JSON Schema
                draft-wright-json-schema-validation-00 specification.
            </t>
        </section>
        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "JSON", "JSON text", "JSON value", "member", "element", "object", "array",
                "number", "string", "boolean", "true", "false", and "null" in this document are to
                be interpreted as defined in <xref target="RFC7159">RFC 7159</xref>.
            </t>
        </section>
        <section title="Overview">
            <t>
                This document describes the JSON Schema restriction rules and all available 
                validation keywords and their corresponding behaviour. It contains
                also a JSON Schema to validate whether a JSON Schema complies to these
                rules.
            </t>
        </section>
        <section title="Restrictions">
            <t>
                The specification distinguishes between three schema types: Definition, 
                Combination and Reference.
            </t>
            <t>
                The distinction is made based on the used keywords.
            </t>
            <section title="Definition">
                <t>
                    A definition schema is a schema which describes a concrete type. 
                    It must follow the rules:
                </t>
                <t>
                    <list style="symbols">
                        <t>
                            Every schema MUST have a "type" keyword. The type must be one of:
                            "object", "array", "boolean", "number", "integer" or "string"
                        </t>
                        <t>
                            Every schema of type "object" MUST have a "title" keyword.
                        </t>
                        <t>
                            Every schema of type "object" is either a struct (MUST have
                            a "properties" keyword) or a map (MUST have a "additionalProperties" 
                            keyword)
                        </t>
                        <t>
                            Every schema of type "array" MUST have an "items" keyword.
                            The items can only contain definition ("object", "boolean", 
                            "number", "string") or reference schemas.
                        </t>
                        <t>
                            The "patternProperties" keyword is not supported.
                        </t>
                    </list>
                </t>
            </section>
            <section title="Combination">
                <t>
                    A combination schema combines multiple schemas in a specific way. 
                    It must follow the rules:
                </t>
                <t>
                    <list style="symbols">
                        <t>
                            Every schema MUST have one of the following keywords:
                            "allOf", "anyOf" or "oneOf"
                        </t>
                        <t>
                            The value must be an array which can contain only definition 
                            (of type "object") or reference schemas.
                        </t>
                    </list>
                </t>
            </section>
            <section title="Reference">
                <t>
                    A reference schema makes a reference to another schema. 
                    It must follow the rules:
                </t>
                <t>
                    <list style="symbols">
                        <t>
                            Every schema MUST have the keyword "$ref".
                        </t>
                        <t>
                            A reference schema MUST follow the same rules as a 
                            definition schema. That means i.e. if a reference is used 
                            inside the "allOf" keyword it MUST only reference object
                            types.
                        </t>
                    </list>
                </t>
            </section>
        </section>
        <section title="Validation">
            <t>
                JSON Schema validators are implemented in a way that they validate json data alongside 
                the data and validate this data according to the keywords which are available. So it is 
                possible to decide which validation keywords should be used depending on the actual data.
            </t>
            <t>
                If a schema follows the rules defined in this specification it can be used independently 
                of the actual data. This means that it is possible to generate i.e. a class representation 
                of the JSON Schema only based on the schema.
            </t>
            <t>
                Because of this critical design change the schema keywords must have some restrictions.
                The following section describes the behaviour of each keyword.
            </t>
            <section title="Definition keywords">
                <t>
                    The following keywords can be used to describe a definition schema.
                </t>
                <section title="Common keywords">
                    <t>
                        The following keywords can be used in any definition schema.
                    </t>
                    <section title="title">
                        <t>
                            The value of this keyword MUST be a string. Should only
                            contain the characters "A-Z", "a-z" and "_"
                        </t>
                        <t>
                            Should be a distinct word which represents this schema,
                            may be used to generate i.e. class names or other identifiers.
                        </t>
                        <t>
                            Schemas with the same title should represent the same constraints
                            since a processor could merge multiple schemas and thus
                            remove duplicate schemas.
                        </t>
                    </section>
                    <section title="description">
                        <t>
                            The value of this keyword MUST be a string.
                        </t>
                        <t>
                            Contains a general description of this property. Should only
                            contain simple text and no line breaks since the description
                            is may be used in code comments or other contexts.
                        </t>
                    </section>
                    <section title="type">
                        <t>
                            The value of this keyword MUST be a string.
                        </t>
                        <t>
                            String values MUST be one of the six primitive types
                            ("boolean", "object", "array", "number", or "string"),
                            or "integer" which matches any number with a zero fractional part.
                        </t>
                        <t>
                            An instance validates if and only if the instance is in any of the sets listed
                            for this keyword.
                        </t>
                    </section>
                    <section title="nullable">
                        <t>
                            The value of this keyword MUST be boolean.
                        </t>
                        <t>
                            Allows sending a null value for the defined schema.
                            Default value is false.
                        </t>
                    </section>
                    <section title="deprecated">
                        <t>
                            The value of this keyword MUST be boolean.
                        </t>
                        <t>
                            Specifies that a property is deprecated and SHOULD be
                            transitioned out of usage. Default value is false.
                        </t>
                    </section>
                </section>
                <section title="Object keywords">
                    <t>
                        If a schema has a "type" keyword which is "object" the following validation
                        keywords can be used.
                    </t>
                    <t>
                        An object must be either a struct or map type. A struct object contains
                        a set of fixed properties and a map object contains variable key value
                        entries.
                    </t>
                    <t>
                        Each object type MUST have also a "title" keyword. The title may be used by a
                        generator to determine a class name for a schema.
                    </t>
                    <section title="required">
                        <t>
                            The value of this keyword MUST be an array.
                            Elements of this array, if any, MUST be strings, and MUST be unique.
                        </t>
                        <t>
                            An object instance is valid against this keyword if every item in the array is
                            the name of a property in the instance.
                        </t>
                        <t>
                            Omitting this keyword has the same behavior as an empty array.
                        </t>
                    </section>
                    <section title="Struct keywords">
                        <t>
                            A struct is an object which MUST have at least a "type",
                            "title" and "properties" keyword.
                        </t>
                        <figure>
                            <artwork>
                                <![CDATA[
{
    "title": "Person",
    "type": "object",
    "properties": {
        "forname": {
            "type": "string"
        },
        "lastname": {
            "type": "string"
        }
    }
}
]]>
                            </artwork>
                        </figure>
                        <section title="properties">
                            <t>
                                The value of "properties" MUST be an object.
                                Each value of this object MUST be a valid JSON Schema.
                            </t>
                            <t>
                                This keyword determines how child instances validate for objects,
                                and does not directly validate the immediate instance itself.
                            </t>
                            <t>
                                Validation succeeds if, for each name that appears in both
                                the instance and as a name within this keyword's value, the child
                                instance for that name successfully validates against the
                                corresponding schema.
                            </t>
                            <t>
                                Omitting this keyword has the same behavior as an empty object.
                            </t>
                        </section>
                    </section>
                    <section title="Map keywords">
                        <t>
                            A map is an object which MUST have at least a "type",
                            "title" and "additionalProperties" keyword.
                        </t>
                        <figure>
                            <artwork>
                                <![CDATA[
{
    "title": "Config",
    "type": "object",
    "additionalProperties": {
        "type": "string"
    }
}
]]>
                            </artwork>
                        </figure>
                        <section title="additionalProperties">
                            <t>
                                The value of "additionalProperties" MUST be a valid JSON Schema.
                            </t>
                            <t>
                                This keyword determines how child instances validate for objects,
                                and does not directly validate the immediate instance itself.
                            </t>
                            <t>
                                For all such properties, validation succeeds if the child instance
                                validates against the "additionalProperties" schema.
                            </t>
                            <t>
                                Omitting this keyword has the same behavior as an empty schema.
                            </t>
                        </section>
                        <section title="maxProperties">
                            <t>
                                The value of this keyword MUST be a non-negative integer.
                            </t>
                            <t>
                                An object instance is valid against "maxProperties" if its
                                number of properties is less than, or equal to, the value of this
                                keyword.
                            </t>
                        </section>
                        <section title="minProperties">
                            <t>
                                The value of this keyword MUST be a non-negative integer.
                            </t>
                            <t>
                                An object instance is valid against "minProperties" if its
                                number of properties is greater than, or equal to, the value of this
                                keyword.
                            </t>
                            <t>
                                Omitting this keyword has the same behavior as a value of 0.
                            </t>
                        </section>
                    </section>
                </section>
                <section title="Array keywords">
                    <t>
                        If a schema has a "type" keyword which is "array" the following validation
                        keywords can be used.
                    </t>
                    <section title="items">
                        <t>
                            The value of "items" MUST be an object. It MUST contain only
                            "object", "number", "integer" or "string" schemas.
                        </t>
                        <t>
                            This keyword determines how child instances validate for arrays,
                            and does not directly validate the immediate instance itself.
                        </t>
                        <t>
                            Omitting this keyword has the same behavior as an empty schema.
                        </t>
                    </section>
                    <section title="maxItems">
                        <t>
                            The value of this keyword MUST be a non-negative integer.
                        </t>
                        <t>
                            An array instance is valid against "maxItems" if its size is
                            less than, or equal to, the value of this keyword.
                        </t>
                    </section>
                    <section title="minItems">
                        <t>
                            The value of this keyword MUST be a non-negative integer.
                        </t>
                        <t>
                            An array instance is valid against "minItems" if its size is
                            greater than, or equal to, the value of this keyword.
                        </t>
                        <t>
                            Omitting this keyword has the same behavior as a value of 0.
                        </t>
                    </section>
                    <section title="uniqueItems">
                        <t>
                            The value of this keyword MUST be a boolean.
                        </t>
                        <t>
                            If this keyword has boolean value false, the instance validates
                            successfully. If it has boolean value true, the instance validates
                            successfully if all of its elements are unique.
                        </t>
                        <t>
                            Omitting this keyword has the same behavior as a value of false.
                        </t>
                    </section>
                </section>
                <section title="Scalar keywords">
                    <t>
                        If a schema has a "type" keyword which is either "boolean", "number" or "string" the
                        following validation keywords can be used.
                    </t>
                    <section title="format">
                        <t>
                            Primitives have an optional modifier keyword "format". There are several
                            known formats to define in fine detail the data type being used.
                        </t>
                        <t>
                            <list style="symbols">
                                <t>int32 (signed 32 bits)</t>
                                <t>int64 (signed 64 bits)</t>
                                <t>float</t>
                                <t>double</t>
                                <t>byte (base64 encoded characters)</t>
                                <t>binary (any sequence of octets)</t>
                                <t>date (as defined by full-date <xref target="RFC3339">RFC 3339</xref>)</t>
                                <t>date-time (as defined by date-time <xref target="RFC3339">RFC 3339</xref>)</t>
                            </list>
                        </t>
                        <t>
                            However, to support documentation needs, the format property is an open
                            string-valued property, and can have any value. Formats such as "email",
                            "uuid", and so on, MAY be used even though undefined by this specification.
                        </t>
                        <t>
                            Types that are not accompanied by a format property follow the type definition
                            in the JSON Schema. Tools that do not recognize a specific format MAY default
                            back to the type alone, as if the format is not specified.
                        </t>
                    </section>
                    <section title="enum">
                        <t>
                            The value of this keyword MUST be an array. This array SHOULD have at
                            least one element. Elements in the array SHOULD be unique.
                        </t>
                        <t>
                            An instance validates successfully against this keyword if its value is
                            equal to one of the elements in this keyword's array value.
                        </t>
                        <t>
                            Elements in the array must contain only string or number values.
                        </t>
                    </section>
                    <section title="Boolean keywords">
                        <t>
                            If a schema has a "type" keyword which is "boolean" no validation keywords
                            are available.
                        </t>
                    </section>
                    <section title="Number keywords">
                        <t>
                            If a schema has a "type" keyword which is either "number" or "integer" the
                            following validation keywords can be used.
                        </t>
                        <section title="multipleOf">
                            <t>
                                The value of "multipleOf" MUST be a number, strictly greater than 0.
                            </t>
                            <t>
                                A numeric instance is valid only if division by this keyword's value results in
                                an integer.
                            </t>
                        </section>
                        <section title="maximum">
                            <t>
                                The value of "maximum" MUST be a number, representing an inclusive upper limit
                                for a numeric instance.
                            </t>
                            <t>
                                If the instance is a number, then this keyword validates only if the instance is
                                less than or exactly equal to "maximum".
                            </t>
                        </section>
                        <section title="exclusiveMaximum">
                            <t>
                                The value of "exclusiveMaximum" MUST be number, representing an exclusive upper
                                limit for a numeric instance.
                            </t>
                            <t>
                                If the instance is a number, then the instance is valid only if it has a value
                                strictly less than (not equal to) "exclusiveMaximum".
                            </t>
                        </section>
                        <section title="minimum">
                            <t>
                                The value of "minimum" MUST be a number, representing an inclusive lower limit
                                for a numeric instance.
                            </t>
                            <t>
                                If the instance is a number, then this keyword validates only if the instance is
                                greater than or exactly equal to "minimum".
                            </t>
                        </section>
                        <section title="exclusiveMinimum">
                            <t>
                                The value of "exclusiveMinimum" MUST be number, representing an exclusive lower
                                limit for a numeric instance.
                            </t>
                            <t>
                                If the instance is a number, then the instance is valid only if it has a value
                                strictly greater than (not equal to) "exclusiveMinimum".
                            </t>
                        </section>
                    </section>
                    <section title="String keywords">
                        <t>
                            If a schema has a "type" keyword which is "string" the following validation
                            keywords can be used.
                        </t>
                        <section title="maxLength">
                            <t>
                                The value of this keyword MUST be a non-negative integer.</t>
                            <t>
                                A string instance is valid against this keyword if its
                                length is less than, or equal to, the value of this keyword.
                            </t>
                            <t>
                                The length of a string instance is defined as the number of its
                                characters as defined by <xref target="RFC7159">RFC 7159</xref>.
                            </t>
                        </section>
                        <section title="minLength">
                            <t>
                                The value of this keyword MUST be a non-negative integer.
                            </t>
                            <t>
                                A string instance is valid against this keyword if its
                                length is greater than, or equal to, the value of this keyword.
                            </t>

                            <t>
                                The length of a string instance is defined as the number of its
                                characters as defined by <xref target="RFC7159">RFC 7159</xref>.
                            </t>
                            <t>
                                Omitting this keyword has the same behavior as a value of 0.
                            </t>
                        </section>
                        <section title="pattern">
                            <t>
                                The value of this keyword MUST be a string. This string SHOULD be a
                                valid regular expression, according to the ECMA 262 regular expression
                                dialect.
                            </t>
                            <t>
                                A string instance is considered valid if the regular
                                expression matches the instance successfully. Recall: regular
                                expressions are not implicitly anchored.
                            </t>
                        </section>
                    </section>
                </section>
            </section>
            <section title="Combination keywords">
                <t>
                    The following keywords can be used to describe a combination schema.
                </t>
                <section title="allOf">
                    <t>
                        This keyword's value MUST be a non-empty array.
                        Each item of the array MUST be a valid object.
                    </t>
                    <t>
                        An instance validates successfully against this keyword if it validates
                        successfully against all schemas defined by this keyword's value.
                    </t>
                    <t>
                        The all of array should be used to express inheritance. The array
                        should list the most generic definition at the first position of
                        the array and the most specific definition at the bottom.
                    </t>
                    <t>
                        Through this code generators could implement inheritance alongside
                        the array.
                    </t>
                    <t>
                        Also it is possible to aggregate all schemas into a single schema. Since the 
                        all of array can only contain schemas of type "object" it is clear that 
                        the result is also always an schema of type "object".
                    </t>
                    <figure>
                        <artwork>
                            <![CDATA[
{
    "allOf": [{
        "$ref": "#/definitions/person"
    }, {
        "title": "teacher",
        "type": "object",
        "properties": {
            "classroom": {
                "type": "string"
            }
        }
    }]
}
]]>
                        </artwork>
                    </figure>
                </section>
                <section title="anyOf">
                    <t>
                        This keyword's value MUST be a non-empty array.
                        Each item of the array MUST be a valid object.
                    </t>
                    <t>
                        An instance validates successfully against this keyword if it validates
                        successfully against at least one schema defined by this keyword's value.
                    </t>
                </section>
                <section title="oneOf">
                    <t>
                        This keyword's value MUST be a non-empty array.
                        Each item of the array MUST be a valid object.
                    </t>
                    <t>
                        An instance validates successfully against this keyword if it validates
                        successfully against exactly one schema defined by this keyword's value.
                    </t>
                </section>
                <section title="discriminator">
                    <t>
                        The value of this keyword MUST be an object.
                    </t>
                    <t>
                        The keyword MUST be only used in combination with the "oneOf" keyword.
                    </t>
                </section>
            </section>
            <section title="Reference keywords">
                <t>
                    The following keywords can be used to describe a reference schema.
                </t>
                <section title="$ref">
                    <t>
                        The "$ref" keyword is used to reference a schema, and provides the ability to
                        validate recursive structures through self-reference.
                    </t>
                    <t>
                        An object schema with a "$ref" property MUST be interpreted as a "$ref" reference.
                        The value of the "$ref" property MUST be a URI Reference.
                        Resolved against the current URI base, it identifies the URI of a schema to use.
                        All other properties in a "$ref" object MUST be ignored.
                    </t>
                    <t>
                        The URI is not a network locator, only an identifier. A schema need not be
                        downloadable from the address if it is a network-addressable URL, and
                        implementations SHOULD NOT assume they should perform a network operation when they
                        encounter a network-addressable URI.
                    </t>
                    <t>
                        A schema MUST NOT be run into an infinite loop against a schema. For example, if two
                        schemas "#alice" and "#bob" both have an "allOf" property that refers to the other,
                        a naive validator might get stuck in an infinite recursive loop trying to validate
                        the instance.
                        Schemas SHOULD NOT make use of infinite recursive nesting like this; the behavior is
                        undefined.
                    </t>
                </section>
            </section>
        </section>
        <section title="Schema">
            <t>
                The following JSON Schema can be used to validate whether a
                JSON Schema follows these rules.
            </t>
            <figure>
                <artwork>
                    <![CDATA[
{
  "description": "A strict JsonSchema meta schema to simplify code generation",
  "oneOf": [{
    "$ref": "#/definitions/definition"
  }, {
    "$ref": "#/definitions/combination"
  }, {
    "$ref": "#/definitions/reference"
  }],
  "definitions": {
    "common": {
      "description": "Common properties which can be used in any schema",
      "title": "common",
      "type": "object",
      "properties": {
        "title": {
          "type": "string",
          "description": "Distinct word which represents this property, may be used to generate i.e. class names or other identifier"
        },
        "description": {
          "type": "string",
          "description": "General description of this property"
        },
        "type": {
          "type": "string",
          "description": "JSON type of the property",
          "enum": ["object", "array", "boolean", "integer", "number", "string"]
        },
        "nullable": {
          "type": "boolean",
          "description": "Whether it is possible to use a null value on this property",
          "default": false
        },
        "deprecated": {
          "type": "boolean",
          "description": "Whether this property is deprecated",
          "default": false
        }
      }
    },
    "commonScalar": {
      "description": "Properties for scalar values",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "scalar",
        "type": "object",
        "properties": {
          "format": {
            "type": "string",
            "description": "Describes the specific format of this type i.e. date-time or int64"
          },
          "enum": {
            "type": "array",
            "description": "A list of possible enumeration values",
            "items": {
              "oneOf": [{
                "type": "string"
              },{
                "type": "number"
              }]
            },
            "minItems": 1
          }
        }
      }]
    },
    "commonContainer": {
      "description": "Properties for object values",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "container",
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "Distinct word which represents this property, may be used to generate i.e. class names or other identifier"
          },
          "type": {
            "type": "string",
            "enum": ["object"]
          },
          "required": { "$ref": "#/definitions/stringArray" }
        },
        "required": ["title", "type"]
      }]
    },
    "object": {
      "description": "An object represents either a struct or map",
      "oneOf": [{
        "$ref": "#/definitions/objectStruct"
      }, {
        "$ref": "#/definitions/objectMap"
      }]
    },
    "objectStruct": {
      "description": "A struct contains a fix set of defined properties",
      "allOf": [{
        "$ref": "#/definitions/commonContainer"
      }, {
        "title": "struct",
        "type": "object",
        "properties": {
          "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" }
          }
        },
        "required": ["properties"]
      }]
    },
    "objectMap": {
      "description": "A map contains variable key value entries",
      "allOf": [{
        "$ref": "#/definitions/commonContainer"
      }, {
        "title": "map",
        "type": "object",
        "properties": {
          "additionalProperties": { "$ref": "#" },
          "maxProperties": { "$ref": "#/definitions/positiveInteger" },
          "minProperties": { "$ref": "#/definitions/positiveInteger" }
        },
        "required": ["additionalProperties"]
      }]
    },
    "array": {
      "description": "An array contains an ordered list of variable values",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "array",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["array"]
          },
          "items": {
            "$ref": "#/definitions/arrayItem"
          },
          "maxItems": { "$ref": "#/definitions/positiveInteger" },
          "minItems": { "$ref": "#/definitions/positiveInteger" },
          "uniqueItems": { 
            "type": "boolean"
          }
        },
        "required": ["type", "items"]
      }]
    },
    "boolean": {
      "description": "Represents a boolean value",
      "allOf": [{
        "$ref": "#/definitions/commonScalar"
      }, {
        "title": "boolean",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["boolean"]
          }
        },
        "required": ["type"]
      }]
    },
    "number": {
      "description": "Represents a number value which contains also integer",
      "allOf": [{
        "$ref": "#/definitions/commonScalar"
      }, {
        "title": "number",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["number", "integer"]
          },
          "multipleOf": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
          },
          "maximum": {
            "type": "number"
          },
          "exclusiveMaximum": {
            "type": "boolean",
            "default": false
          },
          "minimum": {
            "type": "number"
          },
          "exclusiveMinimum": {
            "type": "boolean",
            "default": false
          }
        },
        "required": ["type"]
      }]
    },
    "string": {
      "description": "Represents a string value",
      "allOf": [{
        "$ref": "#/definitions/commonScalar"
      }, {
        "title": "string",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["string"]
          },
          "maxLength": { "$ref": "#/definitions/positiveInteger" },
          "minLength": { "$ref": "#/definitions/positiveInteger" },
          "pattern": {
            "type": "string",
            "format": "regex"
          }
        },
        "required": ["type"]
      }]
    },
    "allOf": {
      "description": "Combination keyword to validate all containing schemas",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "allOf",
        "type": "object",
        "properties": {
          "allOf": { "$ref": "#/definitions/of" }
        },
        "required": ["allOf"]
      }]
    },
    "anyOf": {
      "description": "Combination keyword to validate any containing schemas",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "anyOf",
        "type": "object",
        "properties": {
          "anyOf": { "$ref": "#/definitions/of" }
        },
        "required": ["anyOf"]
      }]
    },
    "oneOf": {
      "description": "Combination keyword to validate exactly one containing schemas",
      "allOf": [{
        "$ref": "#/definitions/common"
      }, {
        "title": "oneOf",
        "type": "object",
        "properties": {
          "discriminator": { "$ref": "#/definitions/discriminator" },
          "oneOf": { "$ref": "#/definitions/of" }
        },
        "required": ["oneOf"]
      }]
    },
    "discriminator": {
      "description": "Adds support for polymorphism. The discriminator is an object name that is used to differentiate between other schemas which may satisfy the payload description",
      "title": "discriminator",
      "type": "object",
      "properties": {
        "propertyName": {
          "type": "string",
          "description": "The name of the property in the payload that will hold the discriminator value"
        },
        "mapping": {
          "type": "object",
          "description": "An object to hold mappings between payload values and schema names or references",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "required": ["propertyName"]
    },
    "positiveInteger": {
      "description": "Positive integer value",
      "type": "integer",
      "minimum": 0
    },
    "stringArray": {
      "description": "Array string values",
      "type": "array",
      "items": { "type": "string" },
      "minItems": 1
    },
    "of": {
      "description": "Combination values",
      "type": "array",
      "items": {
        "$ref": "#/definitions/objectOrReference"
      }
    },
    "objectOrReference": {
      "description": "Object or reference value",
      "oneOf": [{
        "$ref": "#/definitions/object"
      }, {
        "$ref": "#/definitions/reference"
      }]
    },
    "arrayItem": {
      "description": "Allowed values of an array item",
      "oneOf": [{
        "$ref": "#/definitions/object"
      }, {
        "$ref": "#/definitions/boolean"
      }, {
        "$ref": "#/definitions/number"
      }, {
        "$ref": "#/definitions/string"
      }, {
        "$ref": "#/definitions/reference"
      }]
    },
    "definition": {
      "description": "Represents a concrete type definition",
      "oneOf": [{
        "$ref": "#/definitions/object"
      }, {
        "$ref": "#/definitions/array"
      }, {
        "$ref": "#/definitions/boolean"
      }, {
        "$ref": "#/definitions/number"
      }, {
        "$ref": "#/definitions/string"
      }]
    },
    "combination": {
      "description": "Represents a combination of schemas",
      "oneOf": [{
        "$ref": "#/definitions/allOf"
      }, {
        "$ref": "#/definitions/anyOf"
      }, {
        "$ref": "#/definitions/oneOf"
      }]
    },
    "reference": {
      "description": "Represents a reference to another schema",
      "title": "reference",
      "type": "object",
      "properties": {
        "$ref": {
          "type": "string"
        }
      },
      "required": ["$ref"]
    }
  }
}
]]>
                </artwork>
            </figure>
        </section>
    </middle>
    <back>
        <!-- References Section -->
        <references title="Normative References">
            &RFC2119;
            &RFC3339;
            &RFC3986;
            &RFC6901;
            &RFC7159;
        </references>
        <references title="Informative References">
            &RFC7231;
            <reference anchor="json-schema-validation">
                <front>
                    <title>JSON Schema Validation: A Vocabulary for Structural Validation of JSON</title>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <author initials="G." surname="Luff">
                        <organization/>
                    </author>
                    <date year="2016" month="October"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-wright-json-schema-validation-00" />
            </reference>
        </references>
        <section title="Acknowledgments">
            <t>
                Thanks to the JSON Schema and OpenAPI team and contributors.
            </t>
        </section>
        <section title="ChangeLog">
            <t>
                <cref>This section to be removed before leaving Internet-Draft status.</cref>
            </t>
            <t>
                <list style="hanging">
                    <t hangText="draft-kappestein-json-schema-code-00">
                        <list style="symbols">
                            <t>Initial creation</t>
                        </list>
                    </t>
                </list>
            </t>
        </section>
    </back>
</rfc>
